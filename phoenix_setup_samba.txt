#!/bin/bash
# phoenix_setup_samba.sh
# Configures Samba shares for datasets on Proxmox VE for the Phoenix server.
# Version: 1.2.2 (Enhanced Share Configuration)
# Author: Heads, Grok, Devstral

# Source common functions and configuration
source /usr/local/bin/common.sh || { echo "[$(date)] Error: Failed to source common.sh" | tee -a /dev/stderr; exit 1; }
source /usr/local/bin/phoenix_config.sh || { echo "[$(date)] Error: Failed to source phoenix_config.sh" | tee -a /dev/stderr; exit 1; }
# Load configuration
load_config

# Ensure script runs only once (using orchestrator's state mechanism is preferred, but this is a fallback)
STATE_FILE="/var/log/proxmox_setup_state"
MARKER="phoenix_setup_samba_completed_marker"
if grep -Fxq "$MARKER" "$STATE_FILE" 2>/dev/null; then
    echo "[$(date)] phoenix_setup_samba already executed (marker found), skipping" >> "$LOGFILE"
    exit 0
fi

# Parse command-line arguments
PASSWORD=""

while getopts "p:" opt; do
  case $opt in
    p) PASSWORD="$OPTARG" ;;
    \?) echo "[$(date)] Invalid option: -$OPTARG" | tee -a "$LOGFILE" >&2; exit 1 ;;
    :)  echo "[$(date)] Option -$OPTARG requires an argument." | tee -a "$LOGFILE" >&2; exit 1 ;;
  esac
done

# Validate required arguments
if [[ -z "$PASSWORD" ]]; then
    echo "[$(date)] Error: Samba password (-p) is required." | tee -a "$LOGFILE"
    exit 1
fi

# Function to install Samba packages
install_samba_packages() {
    echo "[$(date)] Checking for Samba packages..." >> "$LOGFILE"
    if ! dpkg -l | grep -q "^ii.*samba"; then
        echo "[$(date)] Installing Samba packages..." >> "$LOGFILE"
        retry_command "apt-get update" || { echo "[$(date)] Error: Failed to update package list" | tee -a "$LOGFILE"; exit 1; }
        retry_command "apt-get install -y samba samba-common" || { echo "[$(date)] Error: Failed to install Samba packages" | tee -a "$LOGFILE"; exit 1; }
        echo "[$(date)] Samba packages installed successfully" >> "$LOGFILE"
    else
        echo "[$(date)] Samba packages already installed, skipping installation" >> "$LOGFILE"
    fi
}

# Function to configure Samba user
configure_samba_user() {
    echo "[$(date)] Configuring Samba user: $SMB_USER" >> "$LOGFILE"
    # Create system user if it doesn't exist
    if ! id "$SMB_USER" >/dev/null 2>&1; then
        retry_command "useradd -r -s /usr/sbin/nologin -M $SMB_USER" || { echo "[$(date)] Error: Failed to create system user $SMB_USER" | tee -a "$LOGFILE"; exit 1; }
        echo "[$(date)] Created system user $SMB_USER for Samba" >> "$LOGFILE"
    else
        echo "[$(date)] System user $SMB_USER already exists, skipping creation" >> "$LOGFILE"
    fi

    # Set Samba password using printf to avoid exposing it in command line
    printf "%s\n%s\n" "$PASSWORD" "$PASSWORD" | smbpasswd -s -a "$SMB_USER" || { echo "[$(date)] Error: Failed to set Samba password for $SMB_USER" | tee -a "$LOGFILE"; exit 1; }
    echo "[$(date)] Set Samba password for user $SMB_USER" >> "$LOGFILE"
}

# Function to configure Samba shares (Enhanced)
configure_samba_shares() {
    echo "[$(date)] Configuring Samba shares..." >> "$LOGFILE"
    local smb_conf="/etc/samba/smb.conf"
    local smb_conf_backup="${smb_conf}.phoenix.bak.$(date +%Y%m%d_%H%M%S)"

    # Backup existing smb.conf
    if [[ -f "$smb_conf" ]]; then
        cp "$smb_conf" "$smb_conf_backup" || {
            echo "[$(date)] Error: Failed to backup $smb_conf to $smb_conf_backup" | tee -a "$LOGFILE"
            exit 1
        }
        echo "[$(date)] Backed up $smb_conf to $smb_conf_backup" >> "$LOGFILE"
    fi

    # Create new smb.conf with global section
    cat > "$smb_conf" << EOF
[global]
   workgroup = WORKGROUP
   server string = %h server (Phoenix)
   log file = /var/log/samba/log.%m
   max log size = 1000
   logging = file
   panic action = /usr/share/samba/panic-action %d
   server role = standalone server
   obey pam restrictions = yes
   unix password sync = yes
   passwd program = /usr/bin/passwd %u
   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .
   pam password change = yes
   map to guest = bad user
   usershare allow guests = yes
EOF
    echo "" >> "$smb_conf" # Add a newline after [global]

    # --- Iterate through the dedicated SAMBA_DATASET_LIST ---
    for full_dataset_path in "${SAMBA_DATASET_LIST[@]}"; do
        # Example full_dataset_path: "quickOS/shared-prod-data"

        # Determine pool and dataset name
        local pool dataset_name
        IFS='/' read -r pool dataset_name <<< "$full_dataset_path"
        if [[ -z "$pool" || -z "$dataset_name" ]]; then
            echo "[$(date)] Warning: Invalid dataset path format '$full_dataset_path', skipping." >> "$LOGFILE"
            continue
        fi

        # Check if this dataset is marked for Samba in DATASET_STORAGE_TYPES
        # The value should start with 'smb:' (e.g., 'smb:images')
        local storage_info="${DATASET_STORAGE_TYPES[$full_dataset_path]}"
        if [[ -z "$storage_info" || "$storage_info" != smb:* ]]; then
            echo "[$(date)] Info: Dataset $full_dataset_path not configured for Samba (storage type: ${storage_info:-unset}), skipping." >> "$LOGFILE"
            continue
        fi

        # Extract content type (optional, might be useful for comments or future logic)
        local content_type="${storage_info#smb:}" # Remove 'smb:' prefix

        # Get specific Samba options for this dataset from the new config array
        local share_options="${SAMBA_DATASET_OPTIONS[$full_dataset_path]:-}"
        # If no specific options are defined, use sensible defaults or leave empty
        if [[ -z "$share_options" ]]; then
             echo "[$(date)] Warning: No specific Samba options defined for $full_dataset_path, using minimal defaults." >> "$LOGFILE"
             # Define minimal defaults if needed, or leave empty to rely on [global]
             # share_options="browseable=yes writable=no" # Example minimal defaults
        fi

        # Construct local mount point path (consistent with NFS script)
        local local_mount="${MOUNT_POINT_BASE}/${dataset_name}"

        # Verify ZFS dataset exists
        if ! zfs_dataset_exists "$full_dataset_path"; then
            echo "[$(date)] Error: ZFS dataset $full_dataset_path does not exist, cannot create Samba share." | tee -a "$LOGFILE"
            exit 1
        fi

        # Create local mount point if it doesn't exist
        if [[ ! -d "$local_mount" ]]; then
            mkdir -p "$local_mount" || {
                echo "[$(date)] Error: Failed to create mount point $local_mount for $full_dataset_path" | tee -a "$LOGFILE"
                exit 1
            }
            echo "[$(date)] Created mount point $local_mount for $full_dataset_path" >> "$LOGFILE"
        fi

        # Ensure ZFS dataset is mounted at the correct local path
        # Get current mountpoint from ZFS
        local current_mountpoint
        current_mountpoint=$(zfs get -H -o value mountpoint "$full_dataset_path" 2>/dev/null)
        if [[ "$current_mountpoint" != "$local_mount" ]]; then
            echo "[$(date)] Setting mountpoint for $full_dataset_path to $local_mount" >> "$LOGFILE"
            zfs set mountpoint="$local_mount" "$full_dataset_path" || {
                echo "[$(date)] Error: Failed to set mountpoint for $full_dataset_path to $local_mount" | tee -a "$LOGFILE"
                exit 1
            }
        else
             echo "[$(date)] Mountpoint for $full_dataset_path is already correctly set to $local_mount" >> "$LOGFILE"
        fi

        # --- Generate the share configuration block ---
        # Use the dataset name (without pool) as the share name, replacing '/' with '-'
        local share_name
        share_name=$(echo "$dataset_name" | tr '/' '-')

        {
            echo "[$share_name]"
            echo "   comment = Samba share for $full_dataset_path ($content_type)"
            echo "   path = $local_mount"
            # Force user/group to ensure consistent ownership (often needed)
            echo "   force user = $SMB_USER"
            echo "   force group = $SMB_USER" # Or a specific group if desired
            # Append specific options from config
            if [[ -n "$share_options" ]]; then
                # Process each key=value pair in share_options
                # This handles spaces in values correctly if options are quoted properly in the config
                while IFS='=' read -r key value; do
                    # Trim leading/trailing whitespace (basic)
                    key=$(echo "$key" | xargs)
                    value=$(echo "$value" | xargs)
                    if [[ -n "$key" ]]; then
                         echo "   $key = $value"
                    fi
                done <<< "$(echo "$share_options" | tr ' ' '\n' | paste -d '=' - -)" # Pair up tokens
                # Simpler approach if options are just "key=value key2=value2":
                # echo "   $share_options" | sed 's/^/   /'
            fi
            echo "" # Add blank line after each share block
        } >> "$smb_conf"

        echo "[$(date)] Added Samba share [$share_name] for $full_dataset_path at $local_mount" >> "$LOGFILE"
    done

    echo "[$(date)] Samba shares configured in $smb_conf" >> "$LOGFILE"
}

# Function to restart Samba services
restart_samba_services() {
    echo "[$(date)] Restarting Samba services..." >> "$LOGFILE"
    retry_command "systemctl restart nmbd" || { echo "[$(date)] Error: Failed to restart nmbd service" | tee -a "$LOGFILE"; exit 1; }
    retry_command "systemctl restart smbd" || { echo "[$(date)] Error: Failed to restart smbd service" | tee -a "$LOGFILE"; exit 1; }
    echo "[$(date)] Samba services restarted successfully" >> "$LOGFILE"
}

# Main execution
main() {
    check_root
    # setup_logging # Assume handled by orchestrator

    echo "[$(date)] Starting phoenix_setup_samba.sh" >> "$LOGFILE"

    install_samba_packages
    configure_samba_user
    configure_samba_shares
    restart_samba_services

    # Mark completion using the orchestrator's state file
    echo "$MARKER" >> "$STATE_FILE"
    echo "[$(date)] Successfully completed phoenix_setup_samba.sh" >> "$LOGFILE"
}

main