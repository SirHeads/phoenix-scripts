#!/bin/bash
# create_phoenix.sh
# Orchestrates the execution of all Proxmox VE setup scripts for the Phoenix server
# Version: 1.2.9 (Integrated phoenix_create_storage.sh)
# Author: Heads, Grok, Devstral

# --- Configuration ---
# Log file and state file
LOGFILE="/var/log/proxmox_setup.log"
STATE_FILE="/var/log/proxmox_setup_state"

# --- Function Definitions ---
# Source common functions and configuration
source /usr/local/bin/common.sh || { echo "Error: Failed to source common.sh" | tee -a "$LOGFILE"; exit 1; }
echo "[$(date)] Common functions sourced" >> "$LOGFILE"

source /usr/local/bin/phoenix_config.sh || { echo "Error: Failed to source phoenix_config.sh" | tee -a "$LOGFILE"; exit 1; }
echo "[$(date)] Configuration file sourced" >> "$LOGFILE"

# Load configuration variables (this will validate and set defaults)
load_config
echo "[$(date)] Configuration variables loaded and validated" >> "$LOGFILE"

# Function to check if the script is running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo "Error: This script must be run as root" | tee -a "$LOGFILE"
        exit 1
    fi
    echo "[$(date)] Verified script is running as root" >> "$LOGFILE"
}

# Function to prompt for admin credentials (if not already set)
prompt_for_credentials() {
    # --- Prompt for Admin User Credentials ---
    if [[ -z "$ADMIN_USERNAME" ]]; then
        read -p "Enter admin username for phoenix_create_admin_user.sh [heads]: " ADMIN_USERNAME
        ADMIN_USERNAME=${ADMIN_USERNAME:-heads}
        echo "[$(date)] Set ADMIN_USERNAME to $ADMIN_USERNAME" >> "$LOGFILE"
    fi

    if [[ -z "$ADMIN_PASSWORD" ]]; then
        read -s -p "Enter password for admin user (min 8 chars, 1 special char) [Kick@$$2025]: " ADMIN_PASSWORD
        echo
        ADMIN_PASSWORD=${ADMIN_PASSWORD:-'Kick@$$2025'}
        # Basic password validation (you might want more robust checks)
        if [[ ! "$ADMIN_PASSWORD" =~ [[:punct:]] ]] || [[ ${#ADMIN_PASSWORD} -lt 8 ]]; then
            echo "Error: Password must be at least 8 characters long and contain at least one special character." | tee -a "$LOGFILE"
            exit 1
        fi
        echo "[$(date)] Set ADMIN_PASSWORD (validated)" >> "$LOGFILE"
    fi

    # --- Prompt for SMB Password ---
    if [[ -z "$SMB_PASSWORD" ]]; then
        read -s -p "Enter password for SMB user ($SMB_USER) [Kick@$$2025]: " SMB_PASSWORD
        echo
        SMB_PASSWORD=${SMB_PASSWORD:-'Kick@$$2025'}
        # Basic password validation (you might want more robust checks)
        if [[ ! "$SMB_PASSWORD" =~ [[:punct:]] ]] || [[ ${#SMB_PASSWORD} -lt 8 ]]; then
            echo "Error: SMB Password must be at least 8 characters long and contain at least one special character." | tee -a "$LOGFILE"
            exit 1
        fi
        echo "[$(date)] Set SMB_PASSWORD (validated)" >> "$LOGFILE"
    fi

    # --- Prompt for SSH Public Key ---
    if [[ -z "$ADMIN_SSH_PUBLIC_KEY" ]]; then
        read -p "Enter path to SSH public key file for admin user (or press Enter to skip): " ADMIN_SSH_PUBLIC_KEY_PATH
        if [[ -n "$ADMIN_SSH_PUBLIC_KEY_PATH" ]] && [[ -f "$ADMIN_SSH_PUBLIC_KEY_PATH" ]]; then
            ADMIN_SSH_PUBLIC_KEY=$(cat "$ADMIN_SSH_PUBLIC_KEY_PATH")
            echo "[$(date)] Loaded SSH public key from $ADMIN_SSH_PUBLIC_KEY_PATH" >> "$LOGFILE"
        else
            ADMIN_SSH_PUBLIC_KEY=""
            echo "[$(date)] No SSH public key provided or file not found, skipping SSH key setup." >> "$LOGFILE"
        fi
    fi
}

# Function to prompt for drive selection (if not already set)
prompt_for_drives() {

    # Check if drives are already provided (e.g., from environment or previous run)
    if [[ -n "$QUICKOS_DRIVES_INPUT" ]] && [[ -n "$FASTDATA_DRIVE_INPUT" ]]; then
        echo "[$(date)] Drive selections provided via environment variables, skipping prompts." >> "$LOGFILE"
        return 0
    fi

    # --- Improved Drive Selection Logic ---
    # Discover available NVMe drives by-id, prioritizing model/serial format
    # 1. Get potential drives (filtering out partition links)
    mapfile -t all_nvme_links < <(ls -1 /dev/disk/by-id/nvme-* 2>/dev/null | grep -v -E '\-part[0-9]+$' || true)

    if [[ ${#all_nvme_links[@]} -eq 0 ]]; then
        echo "[$(date)] Error: No NVMe drives found in /dev/disk/by-id/" | tee -a "$LOGFILE"
        exit 1
    fi

    # 2. Deduplicate by underlying device node (/dev/nvme*)
    # Use associative array to store the "best" symlink per device node
    declare -A best_link_for_device

    for link_path in "${all_nvme_links[@]}"; do
        # Resolve the symlink to the actual device node (e.g., /dev/nvme0n1)
        device_node=$(readlink -f "$link_path" 2>/dev/null)
        if [[ -z "$device_node" ]] || [[ ! -b "$device_node" ]]; then
            continue # Skip if it doesn't resolve to a block device
        fi

        link_name=$(basename "$link_path")

        # Criteria for "best" link:
        # Prefer links containing model/serial (Samsung_SSD_...) over generic EUI ones
        current_is_model_serial=false
        if [[ "$link_name" == nvme-*Samsung* || "$link_name" == nvme-*Crucial* || "$link_name" == nvme-*Intel* || "$link_name" == nvme-*WD* ]]; then
             current_is_model_serial=true
        fi

        existing_link="${best_link_for_device[$device_node]}"

        # If no link stored yet for this device, or if current link is better (model/serial vs EUI)
        if [[ -z "$existing_link" ]] || { [[ "$current_is_model_serial" == true ]] && [[ "$existing_link" != nvme-*Samsung* ]] && [[ "$existing_link" != nvme-*Crucial* ]] && [[ "$existing_link" != nvme-*Intel* ]] && [[ "$existing_link" != nvme-*WD* ]]; }; then
            best_link_for_device["$device_node"]="$link_path"
        fi
    done

    # 3. Convert the associative array values (best links) into a list
    available_drives=()
    for drive_link_path in "${best_link_for_device[@]}"; do
         available_drives+=("$drive_link_path")
    done

    # Check if we ended up with any drives after deduplication
    if [[ ${#available_drives[@]} -eq 0 ]]; then
        echo "[$(date)] Error: No usable NVMe drives found after deduplication." | tee -a "$LOGFILE"
        exit 1
    fi

    # Optional: Sort the final list for consistent presentation
    # mapfile -t available_drives < <(printf '%s\n' "${available_drives[@]}" | sort)

    echo "Available NVMe drives:"
    for i in "${!available_drives[@]}"; do
        # Get size using lsblk (assuming /dev/disk/by-id/ links to /dev/)
        drive_path=$(readlink -f "${available_drives[$i]}")
        size=$(lsblk -dn -o SIZE "$drive_path" 2>/dev/null || echo "Unknown")
        echo "  $((i+1)). ${available_drives[$i]##*/} ($size)"
    done

    # --- Select drives for quickOS pool (Mirror) ---
    while true; do
        read -p "Enter two numbers for quickOS pool drives (e.g., 1 2): " QUICKOS_DRIVES_INPUT
        # Basic validation (check if input consists of two numbers)
        if [[ $QUICKOS_DRIVES_INPUT =~ ^[0-9]+[[:space:]]+[0-9]+$ ]]; then
            read -ra quickos_indices <<< "$QUICKOS_DRIVES_INPUT"
            idx1=$((quickos_indices[0] - 1))
            idx2=$((quickos_indices[1] - 1))
            if [[ $idx1 -ge 0 ]] && [[ $idx1 -lt ${#available_drives[@]} ]] && \
               [[ $idx2 -ge 0 ]] && [[ $idx2 -lt ${#available_drives[@]} ]] && \
               [[ $idx1 -ne $idx2 ]]; then
                # Assign full paths
                QUICKOS_DRIVE1="${available_drives[$idx1]}"
                QUICKOS_DRIVE2="${available_drives[$idx2]}"
                echo "[$(date)] Selected quickOS drives: ${QUICKOS_DRIVE1##*/}, ${QUICKOS_DRIVE2##*/}" >> "$LOGFILE"
                break
            fi
        fi
        echo "Invalid input. Please enter two different numbers corresponding to available drives."
    done

    # --- Select drive for fastData pool ---
    # Build list of remaining drives (excluding selected quickOS drives)
    remaining_drives=()
    for drive in "${available_drives[@]}"; do
        if [[ "$drive" != "$QUICKOS_DRIVE1" ]] && [[ "$drive" != "$QUICKOS_DRIVE2" ]]; then
            remaining_drives+=("$drive")
        fi
    done

    if [[ ${#remaining_drives[@]} -eq 0 ]]; then
        echo "[$(date)] Error: No remaining drives available for fastData pool." | tee -a "$LOGFILE"
        exit 1
    fi

    echo "Available NVMe drives (excluding quickOS drives):"
    for i in "${!remaining_drives[@]}"; do
        drive_path=$(readlink -f "${remaining_drives[$i]}")
        size=$(lsblk -dn -o SIZE "$drive_path" 2>/dev/null || echo "Unknown")
        echo "  $((i+1)). ${remaining_drives[$i]##*/} ($size)"
    done

    while true; do
        read -p "Enter number for fastData pool drive (e.g., 3): " FASTDATA_DRIVE_INPUT
        # Basic validation (check if input is a single number)
        if [[ $FASTDATA_DRIVE_INPUT =~ ^[0-9]+$ ]]; then
            idx=$((FASTDATA_DRIVE_INPUT - 1))
            if [[ $idx -ge 0 ]] && [[ $idx -lt ${#remaining_drives[@]} ]]; then
                FASTDATA_DRIVE="${remaining_drives[$idx]}"
                echo "[$(date)] Selected fastData drive: ${FASTDATA_DRIVE##*/}" >> "$LOGFILE"
                break
            fi
        fi
        echo "Invalid input. Please enter a number corresponding to an available drive."
    done

    # Export validated full paths for use in subsequent scripts
    # These are the variables the ZFS pool script expects
    export QUICKOS_DRIVE1 QUICKOS_DRIVE2 FASTDATA_DRIVE
    # Create space-separated string for the pool script argument
    QUICKOS_DRIVES_VALIDATED="$QUICKOS_DRIVE1 $QUICKOS_DRIVE2"
    FASTDATA_DRIVE_VALIDATED="$FASTDATA_DRIVE"
    export QUICKOS_DRIVES_VALIDATED FASTDATA_DRIVE_VALIDATED
}

# Function to validate selected drives are not already in use by ZFS
validate_drives() {
    echo "[$(date)] Validating selected drives are not in use by existing ZFS pools..." >> "$LOGFILE"

    # Combine all selected drives for checking
    ALL_SELECTED_DRIVES=("$QUICKOS_DRIVE1" "$QUICKOS_DRIVE2" "$FASTDATA_DRIVE") # Add STORAGE_NFS_DRIVE if used

    for drive_path in "${ALL_SELECTED_DRIVES[@]}"; do
        # Check if the drive is part of any ZFS pool
        if zpool status | grep -q "$(basename "$drive_path")"; then
             echo "[$(date)] Error: Drive $drive_path is already in use by another ZFS pool." | tee -a "$LOGFILE"
             exit 1
        fi
    done

    echo "[$(date)] Drive validation passed." >> "$LOGFILE"
}

# Function to check if a script has already been completed (based on state file)
is_script_completed() {
    local script_cmd="$1"
    # Check if the state file exists and if the script command is listed in it
    if [[ -f "$STATE_FILE" ]] && grep -Fxq "$script_cmd" "$STATE_FILE"; then
        return 0  # Script found in state file (completed)
    else
        return 1  # Script not found (not completed or state file missing)
    fi
}

# Function to mark a script as completed in the state file
mark_script_completed() {
    local script_cmd="$1"
    # Append the script command to the state file
    echo "$script_cmd" >> "$STATE_FILE"
    echo "[$(date)] Marked script as completed: $script_cmd" >> "$LOGFILE"
}

# Function to clean up state file
cleanup_state() {
    if [[ -f "$STATE_FILE" ]]; then
        rm -f "$STATE_FILE"
        echo "[$(date)] Removed state file: $STATE_FILE" >> "$LOGFILE"
    fi
}

# --- Main Execution ---

# Ensure log file exists and is writable
touch "$LOGFILE" || { echo "Error: Cannot create log file $LOGFILE"; exit 1; }
chmod 644 "$LOGFILE"
echo "[$(date)] Initialized logging for create_phoenix.sh" >> "$LOGFILE"

# Ensure state file exists
touch "$STATE_FILE" || { echo "Error: Cannot create state file $STATE_FILE" | tee -a "$LOGFILE"; exit 1; }
chmod 644 "$STATE_FILE"

check_root
prompt_for_credentials
prompt_for_drives
validate_drives # This sets QUICKOS_DRIVES_VALIDATED and FASTDATA_DRIVE_VALIDATED

# List of setup scripts to execute
# Note: Ensure these scripts exist and are executable
# Use the validated drive paths and admin credentials
scripts=(
    "/usr/local/bin/phoenix_proxmox_initial_setup.sh"
    "/usr/local/bin/phoenix_install_nvidia_driver.sh"
    # Pass SSH key if provided
    "/usr/local/bin/phoenix_create_admin_user.sh -u \"$ADMIN_USERNAME\" -p \"$ADMIN_PASSWORD\"${ADMIN_SSH_PUBLIC_KEY:+ -s \"$ADMIN_SSH_PUBLIC_KEY\"}"
    "if ! dpkg-query -W zfsutils-linux > /dev/null 2>&1; then apt-get update && apt-get install -y zfsutils-linux; fi"
    # Use the validated full paths for ZFS pool creation (Only quickOS and fastData)
    "/usr/local/bin/phoenix_setup_zfs_pools.sh -q \"$QUICKOS_DRIVES_VALIDATED\" -f \"$FASTDATA_DRIVE_VALIDATED\""
    "/usr/local/bin/phoenix_setup_zfs_datasets.sh"
    # --- NEW: Create Proxmox Storage Definitions ---
    "/usr/local/bin/phoenix_create_storage.sh"
    # --- END NEW ---
    "/usr/local/bin/phoenix_setup_nfs.sh --no-reboot"
    "/usr/local/bin/phoenix_setup_samba.sh -p \"$SMB_PASSWORD\""
    # Add more scripts here as needed
)

# Execute scripts in order, skipping completed ones
echo "[$(date)] Starting script execution loop..." >> "$LOGFILE"
# Initialize variables outside the loop to avoid 'local' error
script_path_to_check=""
exit_code=0

for script_cmd in "${scripts[@]}"; do
    # - FIX: Avoid 'local' entirely inside the main script loop -
    # Use regular variables instead of 'local' to prevent scope errors
    # These are effectively local to this loop iteration anyway.
    # Re-initialize for each iteration
    script_path_to_check=""
    exit_code=0

    echo "[$(date)] Checking script: $script_cmd" >> "$LOGFILE"

    # Check if the script is already completed
    if is_script_completed "$script_cmd"; then
        echo "[$(date)] Skipping completed script: $script_cmd" >> "$LOGFILE"
        continue
    fi

    # Check if the script file exists (skip for inline commands like zfsutils-linux check)
    # Extract the script path (first word before any arguments)
    script_path_to_check=$(echo "$script_cmd" | awk '{print $1}')

    if [[ -n "$script_path_to_check" ]] && [[ "$script_path_to_check" != "if" ]] && [[ ! -f "$script_path_to_check" ]]; then
        echo "[$(date)] Error: Script file not found: $script_path_to_check" | tee -a "$LOGFILE"
        exit 1
    fi

    # Execute the script command
    echo "[$(date)] Executing: $script_cmd" >> "$LOGFILE"
    # Use eval to handle arguments and complex commands correctly
    eval "$script_cmd"
    # Capture the exit code immediately after eval
    exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        echo "[$(date)] Error: Failed to execute $script_cmd (exit code: $exit_code). Exiting." | tee -a "$LOGFILE"
        # Optionally, you could add a retry mechanism or prompt to continue
        exit 1
    fi

    # Mark the script as completed
    mark_script_completed "$script_cmd"
done

echo "[$(date)] All scripts executed successfully." >> "$LOGFILE"

# Cleanup state file upon successful completion
cleanup_state

echo "Phoenix Proxmox VE setup completed successfully. State file removed for clean manual rerun." | tee -a "$LOGFILE"